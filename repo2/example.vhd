
----------------------------------------------------------------------------------------------------
--                                                example
----------------------------------------------------------------------------------------------------
-- Descr: VHDL generated by InstantSOC 1.1.0 by FPGA-cores.com
-- Date:  16-06-2020 11:35:48
-- Src:   c:\Users\Leo\OneDrive\Projects\RISC\instantsoc\rc4\example.cpp
----------------------------------------------------------------------------------------------------

----------------
-- LICENSE
----------------
-- Copyright (C) 2019 FPGA-Cores.com. 
-- This code is only free to use for non-commercial use and for evaluation purpose.
-- Commercial use needs a commercial license - contact FPGA-Cores.com.
-- The code is generated on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

-- -------------
-- DISCLAIMER
-- -------------
-- THIS CODE GENERATED BY TOOLS FROM FPGA-Cores.com IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
-- THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FPGA-Cores.com OR ANY 
-- OF THEIR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
-- WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS CODE, EVEN IF 
-- ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--
-- Without limiting the foregoing, FPGA-Cores.com make no warranty that:
--    * the code will meet your requirements.
--    * the code will be uninterrupted, timely, secure or error-free.
--    * the results that may be obtained from the use of the code will be effective, accurate or reliable.
--    * the quality of the code will meet your expectations.
--    * any errors in the tools will be corrected.
--
-- The generated code and its documentation:
--    * could include technical or other mistakes, inaccuracies or typographical errors. 
--    * may be out of date and FPGA-Cores.com, its contributors, and FPGA Cores make no commitment to update such materials.
--
-- The use of the generated code is done at your own discretion and risk and with agreement 
-- that you will be solely responsible for any damage to your system or loss of data that results from such activities. 
-- No advice or information, whether oral or written, obtained by you from FPGA-Cores.com, its website, shall create any warranty for the code.

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity example is
    port(
        clk : in std_logic;
        Gpio0 : out std_logic;
        Gpio1 : out std_logic;
        Gpio2 : out std_logic;
        Gpio3 : out std_logic;
        Gpio4 : out std_logic;
        Gpio5 : out std_logic;
        Gpio6 : out std_logic;
        Gpio7 : out std_logic;
        sw0 : in std_logic;
        sw1 : in std_logic;
        sw2 : in std_logic;
        sw3 : in std_logic;
        sw4 : in std_logic;
        sw5 : in std_logic;
        sw6 : in std_logic;
        sw7 : in std_logic;
        sw8 : in std_logic;
        sw9 : in std_logic;
        sw10 : in std_logic;
        sw11 : in std_logic;
        sw12 : in std_logic;
        sw13 : in std_logic;
        sw14 : in std_logic;
        sw15 : in std_logic;
        led1 : out std_logic;
        led2 : out std_logic;
        led3 : out std_logic;
        led4 : out std_logic;
        led5 : out std_logic;
        led6 : out std_logic;
        led7 : out std_logic;
        led8 : out std_logic;
        led9 : out std_logic;
        led10 : out std_logic;
        led11 : out std_logic;
        led12 : out std_logic;
        led13 : out std_logic;
        led14 : out std_logic;
        led15 : out std_logic;
        sd_seg : out std_logic_vector(7 downto 0);
        sd_sel : out std_logic_vector(7 downto 0)
    );
end entity;

architecture IMPL of example is
constant n0 : unsigned(31 downto 0) := "00000000000000000000001001011000";
constant n1 : integer := 10;
constant n2 : integer := 10;
type n3 is array(0 to 2**n2-1) of std_logic_vector(31 downto 0);
constant n4 : n3 := (
x"00072783",x"0006a683",x"00f50533",x"00054783",x"04078463",x"00000793",x"01b00613",x"00100593",x"01d00513",x"0017f713",x"00f66c63",x"02071063",x"0006a023",x"00178793",x"0017f713",x"fef678e3",
x"0006a023",x"fea798e3",x"00008067",x"00b6a023",x"00178793",x"fe5ff06f",x"00062783",x"01010737",x"0006a023",x"00e7a223",x"00500713",x"00e7a023",x"0007a783",x"00008067",x"fbd50513",x"0ff57513",
x"01400793",x"00a7ee63",x"100007b7",x"00078793",x"00251513",x"00a78533",x"00052503",x"00008067",x"00000513",x"00008067",x"4c4f5737",x"ff010113",x"65670713",x"00e12623",x"10000737",x"00070713",
x"02400793",x"00f707b3",x"0007a683",x"00e14703",x"00052783",x"54454637",x"fff6c693",x"34860613",x"fbd70713",x"00c12423",x"00d7ae23",x"0ff77713",x"01400613",x"fff00693",x"00e66e63",x"100006b7",
x"00068693",x"00271713",x"00e68733",x"00072683",x"fff6c693",x"00d14703",x"00d7ac23",x"01400613",x"fbd70713",x"0ff77713",x"fff00693",x"00e66e63",x"100006b7",x"00068693",x"00271713",x"00e68733",
x"00072683",x"fff6c693",x"00c14703",x"00d7aa23",x"01400613",x"fbd70713",x"0ff77713",x"fff00693",x"00e66e63",x"100006b7",x"00068693",x"00271713",x"00e68733",x"00072683",x"fff6c693",x"00b14703",
x"00d7a823",x"01400613",x"fbd70713",x"0ff77713",x"fff00693",x"00e66e63",x"100006b7",x"00068693",x"00271713",x"00e68733",x"00072683",x"fff6c693",x"00a14703",x"00d7a623",x"01400613",x"fbd70713",
x"0ff77713",x"fff00693",x"00e66e63",x"100006b7",x"00068693",x"00271713",x"00e68733",x"00072683",x"fff6c693",x"00914703",x"00d7a423",x"01400613",x"fbd70713",x"0ff77713",x"fff00693",x"00e66e63",
x"100006b7",x"00068693",x"00271713",x"00e68733",x"00072683",x"fff6c693",x"00814703",x"00d7a223",x"01400613",x"fbd70713",x"0ff77713",x"fff00693",x"00e66e63",x"100006b7",x"00068693",x"00271713",
x"00e68733",x"00072683",x"fff6c693",x"00d7a023",x"01010113",x"00008067",x"d2010113",x"00a00593",x"07810513",x"2c112e23",x"2c812c23",x"2c912a23",x"2d212823",x"2d312623",x"2d412423",x"2d512223",
x"2d612023",x"2b712e23",x"2b812c23",x"2b912a23",x"2ba12823",x"2bb12623",x"215000ef",x"00800593",x"07c10513",x"1ed000ef",x"00400593",x"08010513",x"1e1000ef",x"00400593",x"08410513",x"1d5000ef",
x"00400593",x"08810513",x"1c9000ef",x"00400593",x"08c10513",x"1bd000ef",x"00400593",x"09010513",x"1b1000ef",x"00400593",x"09410513",x"1a5000ef",x"00400593",x"09810513",x"199000ef",x"00400593",
x"09c10513",x"18d000ef",x"00400593",x"0a010513",x"181000ef",x"00400593",x"0a410513",x"175000ef",x"00400593",x"0a810513",x"169000ef",x"00400593",x"0ac10513",x"15d000ef",x"00400593",x"0b010513",
x"151000ef",x"00400593",x"0b410513",x"145000ef",x"00400593",x"0b810513",x"139000ef",x"00400593",x"0bc10513",x"12d000ef",x"00400593",x"0c010513",x"121000ef",x"00400593",x"0c410513",x"115000ef",
x"00400593",x"0c810513",x"109000ef",x"00400593",x"0cc10513",x"0fd000ef",x"00400593",x"0d010513",x"0f1000ef",x"00400593",x"0d410513",x"0e5000ef",x"00400593",x"0d810513",x"0d9000ef",x"00400593",
x"0dc10513",x"0cd000ef",x"00400593",x"0e010513",x"0c1000ef",x"00400593",x"0e410513",x"0b5000ef",x"00400593",x"0e810513",x"0a9000ef",x"00400593",x"0ec10513",x"09d000ef",x"00400593",x"0f010513",
x"091000ef",x"00400593",x"0f410513",x"085000ef",x"00400593",x"0f810513",x"079000ef",x"00400593",x"0fc10513",x"06d000ef",x"00400593",x"10010513",x"061000ef",x"00400593",x"10410513",x"055000ef",
x"00400593",x"10810513",x"049000ef",x"00400593",x"10c10513",x"03d000ef",x"00400593",x"11010513",x"031000ef",x"00400593",x"11410513",x"025000ef",x"00400593",x"11810513",x"019000ef",x"02000593",
x"11c10513",x"00d000ef",x"100007b7",x"00078793",x"0547af83",x"0587af03",x"05c7ae83",x"0607ae03",x"0647a303",x"0687a883",x"06c7a803",x"0707a503",x"0747a583",x"0787a603",x"07c7a683",x"0807a703",
x"13f12023",x"13e12223",x"13d12423",x"13c12623",x"12612823",x"13112a23",x"13012c23",x"12a12e23",x"14b12023",x"14c12223",x"14d12423",x"14e12623",x"14012823",x"14012a23",x"14012c23",x"14012e23",
x"16012023",x"16012223",x"16012423",x"16012623",x"00100713",x"16012823",x"16012c23",x"16012e23",x"18012023",x"18012223",x"18012623",x"18012823",x"18012c23",x"18012e23",x"1a012423",x"14e10923",
x"14e10aa3",x"14e10e23",x"16e10123",x"16e102a3",x"16e10523",x"16e106a3",x"16e10723",x"16e10d23",x"16e10f23",x"18e10123",x"18e102a3",x"18e10623",x"18e10923",x"18e10d23",x"18e10f23",x"1ae10523",
x"16012a23",x"18012423",x"18012a23",x"1a012023",x"1a012223",x"1a012623",x"1ae106a3",x"0847aa83",x"0887aa03",x"08c7a983",x"0907a903",x"0947a483",x"0987a403",x"09c7a083",x"0a47a503",x"0a87a583",
x"0ac7a603",x"0b07a683",x"0a07a803",x"0b87a283",x"0bc7af83",x"0c07af03",x"0c47ae83",x"0c87ae03",x"0cc7a303",x"0d07a883",x"0b47a383",x"1b512823",x"1b412a23",x"1b312c23",x"1b212e23",x"1c912023",
x"1c812223",x"1c112423",x"1ca12823",x"1cb12a23",x"1cc12c23",x"1cd12e23",x"1d012623",x"0d47a803",x"0d87a503",x"0dc7a583",x"0e07a603",x"10100693",x"20012823",x"20012a23",x"20012e23",x"22012023",
x"1e512223",x"1ff12423",x"1fe12623",x"1fd12823",x"1fc12a23",x"1e612c23",x"1f112e23",x"21012023",x"20a12223",x"20b12423",x"20c12623",x"20e10923",x"20d11a23",x"20e10e23",x"22e10123",x"1e712023",
x"20012c23",x"22012223",x"22012423",x"22012623",x"22012823",x"22012a23",x"22012c23",x"22012e23",x"22e102a3",x"24012e23",x"24012023",x"24012223",x"24012623",x"24012823",x"24012a23",x"24012c23",
x"26012423",x"26012623",x"0e47af83",x"0e87af03",x"0ec7ae83",x"0f07ae03",x"0f47a303",x"0f87a883",x"22e10523",x"22e10723",x"22e10da3",x"22d11e23",x"24e10123",x"24e102a3",x"24e10623",x"24e10923",
x"24e10aa3",x"24e10d23",x"24e10ea3",x"24e10f23",x"26e105a3",x"26e10623",x"24012423",x"26012023",x"26012223",x"0fc7a803",x"1007a583",x"1047a603",x"1087a683",x"10c7a703",x"07c12503",x"1107a783",
x"00100293",x"00552023",x"28f12e23",x"010107b7",x"00f52223",x"11012783",x"27f12823",x"27e12a23",x"06f12623",x"0d412783",x"27d12c23",x"27c12e23",x"02f12c23",x"10c12783",x"28612023",x"29112223",
x"29012423",x"28b12623",x"28c12823",x"28d12a23",x"28e12c23",x"11c12603",x"0a012d03",x"11812c83",x"0dc12c03",x"11412b83",x"0d812b03",x"06f12423",x"0d012783",x"00000093",x"02f00593",x"02f12a23",
x"10812783",x"fc100413",x"f8600a93",x"06f12223",x"0cc12783",x"fc600a13",x"f8900993",x"02f12823",x"10412783",x"01010937",x"00500493",x"06f12023",x"0c812783",x"01b00693",x"01d00713",x"02f12623",
x"10012783",x"04f12e23",x"0c412783",x"02f12423",x"0fc12783",x"04f12c23",x"0c012783",x"02f12223",x"0f812783",x"04f12a23",x"0bc12783",x"02f12023",x"0f412783",x"04f12823",x"0b812783",x"00f12e23",
x"0f012783",x"04f12623",x"0b412783",x"00f12c23",x"0ec12783",x"04f12423",x"0b012783",x"08012283",x"08412f83",x"00f12a23",x"0e812783",x"08812f03",x"08c12e83",x"04f12223",x"0ac12783",x"09012e03",
x"09412303",x"00f12823",x"0e412783",x"09812883",x"09c12803",x"04f12023",x"0a812783",x"00f12623",x"0e012783",x"02f12e23",x"0a412783",x"00f12423",x"00100793",x"1215c463",x"00108093",x"fc700593",
x"00b62e23",x"fc000593",x"00b62c23",x"00862a23",x"00862823",x"fce00593",x"00b62623",x"01562423",x"00812583",x"01462223",x"01362023",x"0005a583",x"03c12383",x"00b3a023",x"00c12583",x"04012383",
x"0005a583",x"00b3a023",x"01012583",x"04412383",x"0005a583",x"00b3a023",x"01412583",x"04812383",x"0005a583",x"00b3a023",x"01812583",x"04c12383",x"0005a583",x"00b3a023",x"01c12583",x"05012383",
x"0005a583",x"00b3a023",x"02012583",x"05412383",x"0005a583",x"00b3a023",x"02412583",x"05812383",x"0005a583",x"00b3a023",x"02812583",x"05c12383",x"0005a583",x"00b3a023",x"02c12583",x"06012383",
x"0005a583",x"00b3a023",x"03012583",x"06412383",x"0005a583",x"00b3a023",x"03412583",x"06812383",x"0005a583",x"00b3a023",x"03812583",x"06c12383",x"0005a583",x"00b3a023",x"000b2583",x"00bba023",
x"000c2583",x"00bca023",x"000d2583",x"00f58c63",x"00052583",x"02f00593",x"ee15d0e3",x"00100093",x"eddff06f",x"2a010593",x"001583b3",x"e803c583",x"1e058e63",x"00000593",x"0015fd93",x"00b6ec63",
x"160d9a63",x"0002a023",x"00158593",x"0015fd93",x"feb6f8e3",x"0002a023",x"fee598e3",x"eb03c583",x"1e058263",x"00000593",x"0015fd93",x"00b6ec63",x"140d9863",x"000fa023",x"00158593",x"0015fd93",
x"feb6f8e3",x"000fa023",x"fee598e3",x"ee03c583",x"1c058663",x"00000593",x"0015fd93",x"00b6ec63",x"120d9663",x"000f2023",x"00158593",x"0015fd93",x"feb6f8e3",x"000f2023",x"fee598e3",x"f103c583",
x"1a058a63",x"00000593",x"0015fd93",x"00b6ec63",x"100d9463",x"000ea023",x"00158593",x"0015fd93",x"feb6f8e3",x"000ea023",x"fee598e3",x"f403c583",x"18058e63",x"00000593",x"0015fd93",x"00b6ec63",
x"0e0d9263",x"000e2023",x"00158593",x"0015fd93",x"feb6f8e3",x"000e2023",x"fee598e3",x"f703c583",x"18058263",x"00000593",x"0015fd93",x"00b6ec63",x"0c0d9063",x"00032023",x"00158593",x"0015fd93",
x"feb6f8e3",x"00032023",x"fee598e3",x"fa03c583",x"16058663",x"00000593",x"0015fd93",x"00b6ec63",x"080d9e63",x"0008a023",x"00158593",x"0015fd93",x"feb6f8e3",x"0008a023",x"fee598e3",x"fd03c583",
x"08058a63",x"00000593",x"0015f393",x"00b6ec63",x"06039c63",x"00082023",x"00158593",x"0015f393",x"feb6f8e3",x"00082023",x"e6e584e3",x"00158593",x"fedff06f",x"00f2a023",x"00158593",x"e91ff06f",
x"00ffa023",x"00158593",x"eb5ff06f",x"00ff2023",x"00158593",x"ed9ff06f",x"00fea023",x"00158593",x"efdff06f",x"00fe2023",x"00158593",x"f21ff06f",x"00f32023",x"00158593",x"f45ff06f",x"00f8a023",
x"00158593",x"f69ff06f",x"00f82023",x"00158593",x"f8dff06f",x"00082023",x"01252223",x"00952023",x"00052583",x"00052583",x"dedff06f",x"0002a023",x"01252223",x"00952023",x"00052583",x"eb03c583",
x"e20592e3",x"000fa023",x"01252223",x"00952023",x"00052583",x"ee03c583",x"e2059ee3",x"000f2023",x"01252223",x"00952023",x"00052583",x"f103c583",x"e4059ae3",x"000ea023",x"01252223",x"00952023",
x"00052583",x"f403c583",x"e60596e3",x"000e2023",x"01252223",x"00952023",x"00052583",x"f703c583",x"e80592e3",x"00032023",x"01252223",x"00952023",x"00052583",x"fa03c583",x"e8059ee3",x"0008a023",
x"01252223",x"00952023",x"00052583",x"eb1ff06f",x"0ffff717",x"48c72703",x"00072783",x"00f52023",x"00f585b3",x"00b72023",x"00008067",x"ff010113",x"00812423",x"00058413",x"00000593",x"00112623",
x"fd1ff0ef",x"0ffff797",x"4587a783",x"20000737",x"00e7a023",x"0ffff797",x"4447a783",x"0087a023",x"00c12083",x"00812403",x"01010113",x"00008067", others=>x"00000000");
constant n5 : integer := 9;
type n6 is array(0 to 2**n5-1) of std_logic_vector(31 downto 0);
shared variable n7 : n6 := (
x"00000039",x"00000000",x"00000079",x"00000000",x"00000000",x"00000076",x"00000000",x"00000000",x"00000000",x"00000038",x"00000000",x"00000000",x"0000003f",x"00000000",x"00000000",x"00000000",
x"00000000",x"00000031",x"00000000",x"0000003e",x"0000003e",x"01010000",x"00000101",x"00000000",x"00000001",x"01010000",x"00000101",x"01000000",x"00000101",x"00000000",x"00000000",x"00010100",
x"00010000",x"01010000",x"00000101",x"00000000",x"00000001",x"01010000",x"00000001",x"00010000",x"00000000",x"01010100",x"00010101",x"01010000",x"00000100",x"01010000",x"00000001",x"00000000",
x"00000001",x"00000000",x"00000101",x"00010000",x"00000000",x"01010100",x"00010101",x"01000000",x"00000100",x"00010000",x"00010100",x"00000000",x"00000001",x"01010000",x"00000101",x"01010000",
x"00000101",x"00000000",x"00000000",x"01000000",x"00000001",x"00000000",x"10000128",x"1000012c",x"ffffffff",x"00000000",x"00000000",x"00000000",others=>x"00000000");
type n8 is array(0 to 31) of std_logic_vector(31 downto 0);
signal n9 : n8 := (1=>std_logic_vector(n0), 2=>"0010" & x"0000000", others=>x"00000000");
attribute ram_style : string;
attribute ram_style of n9 : signal is "distributed";
alias n10 : std_logic is clk;
signal n11 : std_logic := '1';
signal n12 : unsigned(31 downto 0) := (others=>'0'); 
signal n13 : unsigned(31 downto 0) := (others=>'0');
signal n14 : std_logic_vector(31 downto 0);
signal n15 : std_logic_vector(31 downto 0);
signal n16 : std_logic:= '0';
alias n17 : std_logic_vector(6 downto 0) is n14(31 downto 25);
alias n18 : std_logic_vector(4 downto 0) is n14(24 downto 20);
alias n19 : std_logic_vector(4 downto 0) is n14(19 downto 15);
alias n20 : std_logic_vector(2 downto 0) is n14(14 downto 12);
alias n21 : std_logic_vector(4 downto 0) is n14(11 downto 7);
alias n22 : std_logic_vector(6 downto 0) is n14(6 downto 0);
alias n23 : std_logic_vector(6 downto 0) is n15(31 downto 25);
alias n24 : std_logic_vector(4 downto 0) is n15(24 downto 20);
alias n25 : std_logic_vector(4 downto 0) is n15(19 downto 15);
alias n26 : std_logic_vector(2 downto 0) is n15(14 downto 12);
alias n27 : std_logic_vector(4 downto 0) is n15(11 downto 7);
alias n28 : std_logic_vector(6 downto 0) is n15(6 downto 0);
signal n29 : std_logic_vector(11 downto 0);
signal n30 : std_logic_vector(11 downto 0);
signal n31 : std_logic_vector(12 downto 1);
signal n32 : std_logic_vector(31 downto 12);
signal n33 : std_logic_vector(20 downto 1);
signal n34 : std_logic_vector(31 downto 0) := (others => '0');
signal n35 : std_logic_vector(31 downto 0) := (others => '0');
signal n36 : signed(31 downto 0);
signal n37 : signed(31 downto 0);
signal n38 : unsigned(31 downto 0);
signal n39 : unsigned(31 downto 0);
signal n40 : std_logic;
signal n41 : std_logic;
signal n42 : std_logic;
signal n43 : signed(11 downto 0);
signal n44 : signed(31 downto 0);
signal n45 : signed(11 downto 0);
signal n46 : signed(31 downto 0);
signal n47 : signed(31 downto 0);
signal n48 : std_logic := '0';
signal n49 : std_logic_vector(31 downto 0);
signal n50 : unsigned(31 downto 0);
signal n51 : unsigned(31 downto 0);
signal n52 : unsigned(63 downto 0);
signal n53 : std_logic := '0';
signal n54 : std_logic := '0';
signal n55 : std_logic := '0';
signal n56 : std_logic := '0';
signal n57 : unsigned(31 downto 0);
signal n58 : unsigned(31 downto 0);
signal n59 : std_logic_vector(31 downto 0);
signal n60 : std_logic_vector(31 downto 0);
signal n61 : std_logic := '0';
signal n62 : std_logic_vector(31 downto 0);
signal n63 : std_logic := '0';
signal n64 : std_logic_vector(31 downto 0);
signal n65 : std_logic := '0';
signal n66 : std_logic := '0';
signal n67 : std_logic_vector(3 downto 0) := "0000";
signal n68 : std_logic_vector(31 downto 0) := (others => '0');
signal n69 : unsigned(31 downto 0) := (others => '0');
signal n70 : std_logic := '0';
signal n71 : std_logic_vector(31 downto 0);
signal n72 : std_logic := '0';
signal n73 : std_logic := '0';
signal n74 : std_logic := '0';
signal n75 : std_logic := '0';
signal n76 : std_logic_vector(0 downto 0) := (others=>'0');
signal n77 : std_logic_vector(0 downto 0) := (others=>'0');
signal n78 : std_logic := '0';
signal n79 : std_logic_vector(31 downto 0) := (others=>'0');
begin
n29 <= n14(31 downto 20);
n30 <= n14(31 downto 25) & n14(11 downto 7);
n31 <= n14(31) & n14(7) & n14(30 downto 25) & n14(11 downto 8);
n32 <= n14(31 downto 12);
n33 <= n14(31) & n14(19 downto 12) & n14(20) & n14(30 downto 21);
n36 <= signed(n34);
n37 <= signed(n35);
n38 <= unsigned(n34);
n39 <= unsigned(n35);
n43 <= signed(n29);
n44 <= resize(n43, 32);
n45 <= signed(n30);
n46 <= resize(n45, 32);
n47 <= signed(n32) & x"000";
n70 <= '1' when (n16 = '1') and (n66 = '1') and (n69(31 downto 28) = x"2") else '0';
n80 : process(n10) is
variable n81 : integer range 0 to 127 := 0;
variable n82 : std_logic := '1';
begin
if rising_edge(n10) then
if n81 = 127 then
n82 := '0';
else
n81 := n81 + 1;
n82 := '1';
end if;
n11 <= n82;
end if;
end process;
n34 <= n9(to_integer(unsigned(n19)));
n35 <= n9(to_integer(unsigned(n18)));
n83: process(n20, n37, n44, n17, n22, n34, n36, n38) is
variable n84 : signed(31 downto 0);
variable n85 : unsigned(31 downto 0);
variable n86 : std_logic_vector(32 downto 0);
variable n87 : signed(32 downto 0);
variable n88 : std_logic;
variable n89 : std_logic;
variable n90 : std_logic;
variable n91 : std_logic;
begin
if n22(5) = '0' then 
n84 := n44;
n85 := unsigned(n44);
n91 := '0';
else 
n84 := signed(n37);
n85 := unsigned(n37);
n91 := n17(5); 
end if;
if n36 < n84 then
n88 := '1';
else
n88 := '0';
end if;
if n38 < n85 then
n89 := '1';
else
n89 := '0';
end if;
if n38 = n85 then
n90 := '1';
else
n90 := '0';
end if;
n40 <= n88; 
n41 <= n89; 
n42 <= n90;
n71 <= (others=>'0');
case n20 is
when "000" => 
if n91 = '1' then
n71 <= std_logic_vector( n36 - n84 );
else
n71 <= std_logic_vector( n36 + n84 );
end if;
when "100" => 
n71 <= std_logic_vector(n36) xor std_logic_vector(n84); 
when "111" => 
n71 <= std_logic_vector(n36) and std_logic_vector(n84);
when "001" => 
case n85(4 downto 0) is
when others => n71 <= std_logic_vector(shift_left(unsigned(n34), 2));
end case;
when others =>
n71 <= (others=>'0');
end case;
end process;
n53 <= n16 when n22 = "0000011" else '0';
n57 <= unsigned(n36 + n44);
n54 <= n53 when n57(31 downto 28) = "0010" else '0';
n56 <= n55 when n58(31 downto 28) = "0010" else '0';
process(n10)
begin
if rising_edge(n10) then
n59 <= n7(to_integer(n57(n5-1+2 downto 0+2)));
end if;
end process;
process (n59, n58, n26 ) is
begin
case n26 is
when "100" => 
case n58(1 downto 0) is
when "00" => 
n60(7 downto 0) <= n59(7 downto 0);
n60(31 downto 8) <= (others=>'0');
when "01" => 
n60(7 downto 0) <= n59(15 downto 8);
n60(31 downto 8) <= (others=>'0');
when "10" => 
n60(7 downto 0) <= n59(23 downto 16);
n60(31 downto 8) <= (others=>'0');
when "11" => 
n60(7 downto 0) <= n59(31 downto 24);
n60(31 downto 8) <= (others=>'0');
when others => 
n60 <= n59;
end case;
when others =>
n60 <= n59;
end case;
end process;
process(n10)
begin
if rising_edge(n10) then
n61 <= n53 and n16;
end if;
end process;
with n58(31 downto 28) select n62 <= 
n60 when "0001", n64 when "0010", x"00000001" when others;
with n58(31 downto 28) select n63 <= 
n61 when "0001", n65 when "0010", '1' when others;
with n58(7 downto 2) select n64 <= 
"0000000000000000000000000000000"&sw0 when "001010",
"0000000000000000000000000000000"&sw1 when "001011",
"0000000000000000000000000000000"&sw2 when "001100",
"0000000000000000000000000000000"&sw3 when "001101",
"0000000000000000000000000000000"&sw4 when "001110",
"0000000000000000000000000000000"&sw5 when "001111",
"0000000000000000000000000000000"&sw6 when "010000",
"0000000000000000000000000000000"&sw7 when "010001",
"0000000000000000000000000000000"&sw8 when "010010",
"0000000000000000000000000000000"&sw9 when "010011",
"0000000000000000000000000000000"&sw10 when "010100",
"0000000000000000000000000000000"&sw11 when "010101",
"0000000000000000000000000000000"&sw12 when "010110",
"0000000000000000000000000000000"&sw13 when "010111",
"0000000000000000000000000000000"&sw14 when "011000",
"0000000000000000000000000000000"&sw15 when "011001",
x"00000001" when others;
with n58(7 downto 2) select n65 <= 
n78 when "000000",
'1' when others;
n69 <= unsigned(n36 + n46);
n66 <= n16 when n22 = "0100011" else '0';
process(n20,n69,n35) is
begin
n68 <= n35;
case n20 is
when "000" =>
case n69(1 downto 0) is
when "00" => 
n67 <= "0001";
n68( 7 downto 0) <= n35(7 downto 0);
when "01" => 
n67 <= "0010";
n68(15 downto 8) <= n35(7 downto 0);
when "10" => 
n67 <= "0100";
n68(23 downto 16) <= n35(7 downto 0);
when "11" => 
n67 <= "1000";
n68(31 downto 24) <= n35(7 downto 0);
when others => n67 <= "0001";
end case;
when "001" =>
if n69(1)='0' then
n67 <= "0011";
else
n67 <= "1100";
n68(31 downto 16) <= n35(15 downto 0);
end if;
when others =>
n67 <= "1111";
end case;
end process;
WRP : process(n10)
begin
if rising_edge(n10) then
if( n66 = '1' and n69(31 downto 28) = "0001" ) then
if n67(0) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(7 downto 0) := n68(7 downto 0);
end if;
if n67(1) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(15 downto 8) := n68(15 downto 8);
end if;
if n67(2) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(23 downto 16) := n68(23 downto 16);
end if;
if n67(3) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(31 downto 24) := n68(31 downto 24);
end if;
end if;
end if;
end process;
n92 : process(n10) is
variable n93 : integer range 0 to n1 := 0;
begin
if rising_edge(n10) then 
n75 <= '0';
if n93 = n1 then
n75 <= '1';
n93 := 0;
end if;
n93 := n93 + 1;
end if;
end process;
n94 : process(n10) is
variable n95 : integer range 0 to 1000 := 0;
begin
if rising_edge(n10) then
n74 <= '0';
if n95 = 1000 then
n74 <= '1';
n95 := 0;
end if;
if n75 = '1' then
n95 := n95 + 1;
end if;
end if;
end process;
n96 : process(n10) is
variable n97 : unsigned(31 downto 0) := to_unsigned(0, 32);
variable n98 : unsigned(31 downto 0) := to_unsigned(0, 32);
variable n99 : std_logic := '0';
begin
if rising_edge(n10) then
n78 <= '0';
if n11 = '1' then
n97 := (others=>'0');
n98 := (others=>'0');
n79 <= (others=>'0');
elsif n70='1' and n69(7 downto 2) = "000000" then 
n97 := unsigned(n68);
n98 := unsigned(n68);
elsif n70='1' and n69(7 downto 2) = "000001" then 
n79 <= n68;
else
if n79(16) = '1' then
if n97 = x"00000000" then
n97 := n98;
n78 <= '1';
n76(0) <= n79(17);
else
case n79(25 downto 24) is
when "00" =>
n99 := '1';
when "01" =>
n99 := n75;
when "10" =>
n99 := n74;
when others =>
n99 := '0';
end case;
if n99 = '1' then
n97 := n97 - 1;
end if;
end if;
end if;
end if;
if n77(0) = '1' then
n76(0) <= '0';
end if;
end if;
end process;
n100 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio0 <= '0';
elsif n70='1' and n69(7 downto 2) = "000010" then 
Gpio0 <= n68(0);
end if;
end if;
end process;
n101 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio1 <= '0';
elsif n70='1' and n69(7 downto 2) = "000011" then 
Gpio1 <= n68(0);
end if;
end if;
end process;
n102 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio2 <= '0';
elsif n70='1' and n69(7 downto 2) = "000100" then 
Gpio2 <= n68(0);
end if;
end if;
end process;
n103 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio3 <= '0';
elsif n70='1' and n69(7 downto 2) = "000101" then 
Gpio3 <= n68(0);
end if;
end if;
end process;
n104 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio4 <= '0';
elsif n70='1' and n69(7 downto 2) = "000110" then 
Gpio4 <= n68(0);
end if;
end if;
end process;
n105 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio5 <= '0';
elsif n70='1' and n69(7 downto 2) = "000111" then 
Gpio5 <= n68(0);
end if;
end if;
end process;
n106 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio6 <= '0';
elsif n70='1' and n69(7 downto 2) = "001000" then 
Gpio6 <= n68(0);
end if;
end if;
end process;
n107 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio7 <= '0';
elsif n70='1' and n69(7 downto 2) = "001001" then 
Gpio7 <= n68(0);
end if;
end if;
end process;
n108 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led1 <= '0';
elsif n70='1' and n69(7 downto 2) = "011010" then 
led1 <= n68(0);
end if;
end if;
end process;
n109 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led2 <= '0';
elsif n70='1' and n69(7 downto 2) = "011011" then 
led2 <= n68(0);
end if;
end if;
end process;
n110 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led3 <= '0';
elsif n70='1' and n69(7 downto 2) = "011100" then 
led3 <= n68(0);
end if;
end if;
end process;
n111 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led4 <= '0';
elsif n70='1' and n69(7 downto 2) = "011101" then 
led4 <= n68(0);
end if;
end if;
end process;
n112 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led5 <= '0';
elsif n70='1' and n69(7 downto 2) = "011110" then 
led5 <= n68(0);
end if;
end if;
end process;
n113 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led6 <= '0';
elsif n70='1' and n69(7 downto 2) = "011111" then 
led6 <= n68(0);
end if;
end if;
end process;
n114 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led7 <= '0';
elsif n70='1' and n69(7 downto 2) = "100000" then 
led7 <= n68(0);
end if;
end if;
end process;
n115 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led8 <= '0';
elsif n70='1' and n69(7 downto 2) = "100001" then 
led8 <= n68(0);
end if;
end if;
end process;
n116 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led9 <= '0';
elsif n70='1' and n69(7 downto 2) = "100010" then 
led9 <= n68(0);
end if;
end if;
end process;
n117 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led10 <= '0';
elsif n70='1' and n69(7 downto 2) = "100011" then 
led10 <= n68(0);
end if;
end if;
end process;
n118 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led11 <= '0';
elsif n70='1' and n69(7 downto 2) = "100100" then 
led11 <= n68(0);
end if;
end if;
end process;
n119 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led12 <= '0';
elsif n70='1' and n69(7 downto 2) = "100101" then 
led12 <= n68(0);
end if;
end if;
end process;
n120 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led13 <= '0';
elsif n70='1' and n69(7 downto 2) = "100110" then 
led13 <= n68(0);
end if;
end if;
end process;
n121 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led14 <= '0';
elsif n70='1' and n69(7 downto 2) = "100111" then 
led14 <= n68(0);
end if;
end if;
end process;
n122 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
led15 <= '0';
elsif n70='1' and n69(7 downto 2) = "101000" then 
led15 <= n68(0);
end if;
end if;
end process;
n123 : process(n10) is
subtype n124 is std_logic_vector(7 downto 0);
type n125 is array (0 to 7) of n124;
variable n126 : n125 := (others=>"00000000");
variable n127 : integer range 0 to 125 := 0;
variable n128 : std_logic_vector(7 downto 0) := "00000001";
begin
if rising_edge(n10) then
if n70='1' then
if n69(7 downto 2) = "101001" then 
n126(0) := n68(7 downto 0);
elsif n69(7 downto 2) = "101010" then 
n126(1) := n68(7 downto 0);
elsif n69(7 downto 2) = "101011" then 
n126(2) := n68(7 downto 0);
elsif n69(7 downto 2) = "101100" then 
n126(3) := n68(7 downto 0);
elsif n69(7 downto 2) = "101101" then 
n126(4) := n68(7 downto 0);
elsif n69(7 downto 2) = "101110" then 
n126(5) := n68(7 downto 0);
elsif n69(7 downto 2) = "101111" then 
n126(6) := n68(7 downto 0);
elsif n69(7 downto 2) = "110000" then 
n126(7) := n68(7 downto 0);
end if;
end if;
if n75 = '1' then
if n127 = 125 then
n127 := 0;
if n128(n128'high) = '1' then 
n128 := "00000001";
else
n128 := n128(n128'high-1 downto 0)&'0';
end if;
else
n127 := n127 + 1;
end if;
end if;
if n128(0) = '1' then
sd_seg <= n126(0);
elsif n128(1) = '1' then
sd_seg <= n126(1);
elsif n128(2) = '1' then
sd_seg <= n126(2);
elsif n128(3) = '1' then
sd_seg <= n126(3);
elsif n128(4) = '1' then
sd_seg <= n126(4);
elsif n128(5) = '1' then
sd_seg <= n126(5);
elsif n128(6) = '1' then
sd_seg <= n126(6);
elsif n128(7) = '1' then
sd_seg <= n126(7);
end if;
sd_sel <= not n128;
end if;
end process;
process( n10 ) is
variable n129 : std_logic := '0';
variable n130 : std_logic_vector(1 downto 0);
variable n131 : std_logic := '0'; 
variable n132 : std_logic_vector(31 downto 0); 
variable n133 : std_logic_vector(4 downto 0) := "00010";
variable n134 : unsigned(31 downto 0) := n0; 
variable n135 : std_logic := '0'; 
variable n136 : unsigned(31 downto 0); 
variable n137 : std_logic:= '0'; 
variable n138 : std_logic := '0';
variable n139 : std_logic := '0';
variable n140 : unsigned(31 downto 0) := n0; 
variable n141 : std_logic_vector(31 downto 0); 
begin
if rising_edge( n10 ) then
n129 := '0';
n137 := '1';
n135 := '0';
n131 := '0'; 
n132 := "0010" & x"0000000";
n55 <= '0';
if n139 = '1' then 
if n48 = '1' then
n131 := '1';
n132 := n49;
n139 := '0';
else
n130 := "00";
n129 := '1';
n137 := '0';
end if;
elsif n138 = '1' then
n55 <= '1';
if n63 = '1' then
n131 := '1';
n132 := n62;
n138 := '0';
else
n130 := "00";
n129 := '1';
n137 := '0';
end if;
elsif n16 = '1' then
n133 := n21;
n58 <= n57;
n15 <= n14;
case n22 is
when "0110111" => 
n131 := '1';
n132(31 downto 12) := n32;
when "0010111" => 
n131 := '1'; 
n132 := std_logic_vector( signed(n12) + n47 );
when "1101111" => 
n131 := '1'; 
n132 := std_logic_vector(n140); 
n136 := unsigned( signed(n12) + signed(n33&'0') );
n135 := '1';
when "1100111" => 
n131 := '1'; 
n132 := std_logic_vector(n140); 
n136 := unsigned(n43 + n36);
n135 := '1';
when "1100011" => 
n136 := unsigned( signed(n12) + signed(n31&'0') );
case n20 is 
when "000" => 
if n42 = '1' then
n135 := '1';
end if;
when "001" => 
if n42 = '0' then
n135 := '1';
end if;
when "100" => 
if n40 = '1' then
n135 := '1';
end if;
when "101" => 
if n40 = '0' then
n135 := '1';
end if;
when "110" => 
if n41 = '1' then
n135 := '1';
end if;
when "111" => 
if n41 = '0' then
n135 := '1';
end if;
when others=>
end case;
when "0000011" => 
n130 := "00";
n129 := '1';
n137 := '0';
n138 := '1';
when "0100011" => 
when "0010011" => 
n131 := '1';
n132 := n71;
when "0110011" => 
n131 := '1';
n132 := n71;
when others =>
end case;
end if; 
if n11 = '1' then
n130 := "00";
n129 := '1';
n134 := n0;
n140 := n0;
n131 := '1';
n135 := '0';
n137 := '0';
n138 := '0';
n139 := '0';
elsif n135 = '1' then 
n130 := "00";
n129 := '1';
n134(n2-1+2 downto 0+2) := n136(n2-1+2 downto 0+2); 
elsif n137 = '1' then
n134(n2-1+2 downto 0+2) := n134(n2-1+2 downto 0+2)+1;
n129 := '1';
end if;
n13 <= n12;
n130 := n130(0) & n129;
n16 <= n130(1);
if (n131 = '1') and (n133 /= "00000") then
n9(to_integer(unsigned(n133))) <= n132;
end if;
if n11 = '1' then
n133 := "00010";
end if;
n14 <= n141;
n12 <= n140;
n141 := n4(to_integer(n134(n2-1+2 downto 0+2)));
n140 :=n134;
end if;
end process;
end architecture;
