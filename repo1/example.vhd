
----------------------------------------------------------------------------------------------------
--                                                example
----------------------------------------------------------------------------------------------------
-- Descr: VHDL generated by InstantSOC 1.1.0 by FPGA-cores.com
-- Date:  14-06-2020 22:24:08
-- Src:   c:\Users\tbh\Desktop\instantSoC_test\example.cpp
----------------------------------------------------------------------------------------------------

----------------
-- LICENSE
----------------
-- Copyright (C) 2019 FPGA-Cores.com. 
-- This code is only free to use for non-commercial use and for evaluation purpose.
-- Commercial use needs a commercial license - contact FPGA-Cores.com.
-- The code is generated on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

-- -------------
-- DISCLAIMER
-- -------------
-- THIS CODE GENERATED BY TOOLS FROM FPGA-Cores.com IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
-- THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FPGA-Cores.com OR ANY 
-- OF THEIR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
-- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
-- WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS CODE, EVEN IF 
-- ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--
-- Without limiting the foregoing, FPGA-Cores.com make no warranty that:
--    * the code will meet your requirements.
--    * the code will be uninterrupted, timely, secure or error-free.
--    * the results that may be obtained from the use of the code will be effective, accurate or reliable.
--    * the quality of the code will meet your expectations.
--    * any errors in the tools will be corrected.
--
-- The generated code and its documentation:
--    * could include technical or other mistakes, inaccuracies or typographical errors. 
--    * may be out of date and FPGA-Cores.com, its contributors, and FPGA Cores make no commitment to update such materials.
--
-- The use of the generated code is done at your own discretion and risk and with agreement 
-- that you will be solely responsible for any damage to your system or loss of data that results from such activities. 
-- No advice or information, whether oral or written, obtained by you from FPGA-Cores.com, its website, shall create any warranty for the code.

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity example is
    port(
        clk : in std_logic;
        Gpio0 : out std_logic;
        Gpio1 : out std_logic;
        Gpio2 : out std_logic;
        Gpio3 : out std_logic;
        Gpio4 : out std_logic;
        Gpio5 : out std_logic;
        Gpio6 : out std_logic;
        Gpio7 : out std_logic
    );
end entity;

architecture IMPL of example is
constant n0 : unsigned(31 downto 0) := "00000000000000000000000001111000";
constant n1 : integer := 10;
constant n2 : integer := 9;
type n3 is array(0 to 2**n2-1) of std_logic_vector(31 downto 0);
constant n4 : n3 := (
x"00072783",x"0006a683",x"00f50533",x"00054783",x"04078463",x"00000793",x"01700613",x"00100593",x"01d00513",x"0017f713",x"00f66c63",x"02071063",x"0006a023",x"00178793",x"0017f713",x"fef678e3",
x"0006a023",x"fea798e3",x"00008067",x"00b6a023",x"00178793",x"fe5ff06f",x"00062783",x"01010737",x"0006a023",x"00e7a223",x"00500713",x"00e7a023",x"0007a783",x"00008067",x"db010113",x"00a00593",
x"00810513",x"24112623",x"24912223",x"23312e23",x"24812423",x"25212023",x"574000ef",x"00800593",x"00c10513",x"54c000ef",x"00400593",x"01010513",x"540000ef",x"00400593",x"01410513",x"534000ef",
x"00400593",x"01810513",x"528000ef",x"00400593",x"01c10513",x"51c000ef",x"00400593",x"02010513",x"510000ef",x"00400593",x"02410513",x"504000ef",x"00400593",x"02810513",x"4f8000ef",x"00400593",
x"02c10513",x"4ec000ef",x"100004b7",x"04000613",x"00000593",x"03010513",x"538000ef",x"00048993",x"07010793",x"00048493",x"04098713",x"0004a503",x"0044a583",x"0084a603",x"00c4a683",x"00a7a023",
x"00b7a223",x"00c7a423",x"00d7a623",x"01048493",x"01078793",x"fce49ce3",x"04000613",x"00000593",x"0b010513",x"4ec000ef",x"00100413",x"10100913",x"04000613",x"00000593",x"0f010513",x"0a810823",
x"0a810da3",x"0d211023",x"0c8101a3",x"0c810223",x"0c810423",x"0c8105a3",x"0c810823",x"0c8109a3",x"0c810c23",x"0d211d23",x"0e8100a3",x"0e8104a3",x"4a0000ef",x"04000613",x"00000593",x"13010513",
x"0e810823",x"0e810d23",x"10810023",x"10810423",x"108105a3",x"10810823",x"108109a3",x"10810c23",x"10810d23",x"13211023",x"12810123",x"13211423",x"12810523",x"45c000ef",x"010107b7",x"10178793",
x"04000613",x"00000593",x"17010513",x"14f12423",x"14f12823",x"12810823",x"12810d23",x"14810023",x"14810ca3",x"14810d23",x"168100a3",x"168104a3",x"420000ef",x"04000613",x"00000593",x"1b010513",
x"16810823",x"16810ca3",x"18810023",x"18810223",x"19211523",x"19211923",x"18810ca3",x"1a8100a3",x"1a8104a3",x"3ec000ef",x"1f010793",x"1a810823",x"1b211c23",x"1d211023",x"1c8101a3",x"1c810223",
x"1c810523",x"1c810923",x"1d211c23",x"1e8100a3",x"1e810123",x"1e8104a3",x"1e810523",x"08098993",x"0004a583",x"0044a603",x"0084a683",x"00c4a703",x"00b7a023",x"00c7a223",x"00d7a423",x"00e7a623",
x"01048493",x"01078793",x"fd349ce3",x"00c12783",x"00100713",x"01012083",x"01412383",x"01812283",x"01c12f83",x"02012f03",x"02412e83",x"02812e03",x"02c12303",x"00e7a023",x"01010737",x"00e7a223",
x"00000413",x"03f00493",x"00100593",x"010108b7",x"00500813",x"01700613",x"01d00693",x"1884ce63",x"00140413",x"23010513",x"00040713",x"00e50733",x"e0074503",x"18050e63",x"00000513",x"00157913",
x"00a66c63",x"24091663",x"0000a023",x"00150513",x"00157913",x"fea678e3",x"0000a023",x"fed518e3",x"e4074503",x"18050263",x"00000513",x"00157913",x"00a66c63",x"22091463",x"0003a023",x"00150513",
x"00157913",x"fea678e3",x"0003a023",x"fed518e3",x"e8074503",x"16050663",x"00000513",x"00157913",x"00a66c63",x"20091263",x"0002a023",x"00150513",x"00157913",x"fea678e3",x"0002a023",x"fed518e3",
x"ec074503",x"14050a63",x"00000513",x"00157913",x"00a66c63",x"1e091063",x"000fa023",x"00150513",x"00157913",x"fea678e3",x"000fa023",x"fed518e3",x"f0074503",x"12050e63",x"00000513",x"00157913",
x"00a66c63",x"1a091e63",x"000f2023",x"00150513",x"00157913",x"fea678e3",x"000f2023",x"fed518e3",x"f4074503",x"12050263",x"00000513",x"00157913",x"00a66c63",x"18091c63",x"000ea023",x"00150513",
x"00157913",x"fea678e3",x"000ea023",x"fed518e3",x"f8074503",x"10050663",x"00000513",x"00157913",x"00a66c63",x"16091a63",x"000e2023",x"00150513",x"00157913",x"fea678e3",x"000e2023",x"fed518e3",
x"fc074703",x"0e070a63",x"00000713",x"00177513",x"00e66c63",x"14051863",x"00032023",x"00170713",x"00177513",x"fee678e3",x"00032023",x"fed718e3",x"0007a703",x"e684d6e3",x"23010513",x"00100713",
x"00e50733",x"e0074503",x"00100413",x"e60516e3",x"0000a023",x"0117a223",x"0107a023",x"0007a503",x"e4074503",x"e80512e3",x"0003a023",x"0117a223",x"0107a023",x"0007a503",x"e8074503",x"e8051ee3",
x"0002a023",x"0117a223",x"0107a023",x"0007a503",x"ec074503",x"ea051ae3",x"000fa023",x"0117a223",x"0107a023",x"0007a503",x"f0074503",x"ec0516e3",x"000f2023",x"0117a223",x"0107a023",x"0007a503",
x"f4074503",x"ee0512e3",x"000ea023",x"0117a223",x"0107a023",x"0007a503",x"f8074503",x"ee051ee3",x"000e2023",x"0117a223",x"0107a023",x"fc074703",x"0007a503",x"f0071ae3",x"00032023",x"0117a223",
x"0107a023",x"0007a703",x"0007a703",x"f29ff06f",x"00b0a023",x"00150513",x"db9ff06f",x"00b3a023",x"00150513",x"dddff06f",x"00b2a023",x"00150513",x"e01ff06f",x"00bfa023",x"00150513",x"e25ff06f",
x"00bf2023",x"00150513",x"e49ff06f",x"00bea023",x"00150513",x"e6dff06f",x"00be2023",x"00150513",x"e91ff06f",x"00b32023",x"00170713",x"eb5ff06f",x"10000717",x"a9872703",x"00072783",x"00f52023",
x"00f585b3",x"00b72023",x"00008067",x"ff010113",x"00812423",x"00058413",x"00000593",x"00112623",x"fd1ff0ef",x"10000797",x"a647a783",x"20000737",x"00e7a023",x"10000797",x"a507a783",x"0087a023",
x"00c12083",x"00812403",x"01010113",x"00008067",x"00f00313",x"00050713",x"02c37e63",x"00f77793",x"0a079063",x"08059263",x"ff067693",x"00f67613",x"00e686b3",x"00b72023",x"00b72223",x"00b72423",
x"00b72623",x"01070713",x"fed766e3",x"00061463",x"00008067",x"40c306b3",x"00269693",x"00000297",x"005686b3",x"00c68067",x"00b70723",x"00b706a3",x"00b70623",x"00b705a3",x"00b70523",x"00b704a3",
x"00b70423",x"00b703a3",x"00b70323",x"00b702a3",x"00b70223",x"00b701a3",x"00b70123",x"00b700a3",x"00b70023",x"00008067",x"0ff5f593",x"00859693",x"00d5e5b3",x"01059693",x"00d5e5b3",x"f6dff06f",
x"00279693",x"00000297",x"005686b3",x"00008293",x"fa0680e7",x"00028093",x"ff078793",x"40f70733",x"00f60633",x"f6c378e3",x"f3dff06f", others=>x"00000000");
constant n5 : integer := 8;
type n6 is array(0 to 2**n5-1) of std_logic_vector(31 downto 0);
shared variable n7 : n6 := (
x"00000001",x"00000000",x"01010101",x"00000001",x"01010100",x"00000000",x"01010101",x"00000000",x"01010101",x"00000000",x"01000001",x"00000000",x"00000100",x"00000000",x"00000100",x"00000000",
x"01010101",x"00000001",x"01010101",x"00000001",x"01010100",x"00000000",x"00000100",x"00000000",x"00000100",x"00000000",x"00000001",x"00000000",x"00000000",x"00000000",x"00000000",x"00000000",
x"00000000",x"10000094",x"10000098",x"ffffffff",x"00000000",x"00000000",x"00000000",others=>x"00000000");
type n8 is array(0 to 31) of std_logic_vector(31 downto 0);
signal n9 : n8 := (1=>std_logic_vector(n0), 2=>"0010" & x"0000000", others=>x"00000000");
attribute ram_style : string;
attribute ram_style of n9 : signal is "distributed";
alias n10 : std_logic is clk;
signal n11 : std_logic := '1';
signal n12 : unsigned(31 downto 0) := (others=>'0'); 
signal n13 : unsigned(31 downto 0) := (others=>'0');
signal n14 : std_logic_vector(31 downto 0);
signal n15 : std_logic_vector(31 downto 0);
signal n16 : std_logic:= '0';
alias n17 : std_logic_vector(6 downto 0) is n14(31 downto 25);
alias n18 : std_logic_vector(4 downto 0) is n14(24 downto 20);
alias n19 : std_logic_vector(4 downto 0) is n14(19 downto 15);
alias n20 : std_logic_vector(2 downto 0) is n14(14 downto 12);
alias n21 : std_logic_vector(4 downto 0) is n14(11 downto 7);
alias n22 : std_logic_vector(6 downto 0) is n14(6 downto 0);
alias n23 : std_logic_vector(6 downto 0) is n15(31 downto 25);
alias n24 : std_logic_vector(4 downto 0) is n15(24 downto 20);
alias n25 : std_logic_vector(4 downto 0) is n15(19 downto 15);
alias n26 : std_logic_vector(2 downto 0) is n15(14 downto 12);
alias n27 : std_logic_vector(4 downto 0) is n15(11 downto 7);
alias n28 : std_logic_vector(6 downto 0) is n15(6 downto 0);
signal n29 : std_logic_vector(11 downto 0);
signal n30 : std_logic_vector(11 downto 0);
signal n31 : std_logic_vector(12 downto 1);
signal n32 : std_logic_vector(31 downto 12);
signal n33 : std_logic_vector(20 downto 1);
signal n34 : std_logic_vector(31 downto 0) := (others => '0');
signal n35 : std_logic_vector(31 downto 0) := (others => '0');
signal n36 : signed(31 downto 0);
signal n37 : signed(31 downto 0);
signal n38 : unsigned(31 downto 0);
signal n39 : unsigned(31 downto 0);
signal n40 : std_logic;
signal n41 : std_logic;
signal n42 : std_logic;
signal n43 : signed(11 downto 0);
signal n44 : signed(31 downto 0);
signal n45 : signed(11 downto 0);
signal n46 : signed(31 downto 0);
signal n47 : signed(31 downto 0);
signal n48 : std_logic := '0';
signal n49 : std_logic_vector(31 downto 0);
signal n50 : unsigned(31 downto 0);
signal n51 : unsigned(31 downto 0);
signal n52 : unsigned(63 downto 0);
signal n53 : std_logic := '0';
signal n54 : std_logic := '0';
signal n55 : std_logic := '0';
signal n56 : std_logic := '0';
signal n57 : unsigned(31 downto 0);
signal n58 : unsigned(31 downto 0);
signal n59 : std_logic_vector(31 downto 0);
signal n60 : std_logic_vector(31 downto 0);
signal n61 : std_logic := '0';
signal n62 : std_logic_vector(31 downto 0);
signal n63 : std_logic := '0';
signal n64 : std_logic_vector(31 downto 0);
signal n65 : std_logic := '0';
signal n66 : std_logic := '0';
signal n67 : std_logic_vector(3 downto 0) := "0000";
signal n68 : std_logic_vector(31 downto 0) := (others => '0');
signal n69 : unsigned(31 downto 0) := (others => '0');
signal n70 : std_logic := '0';
signal n71 : std_logic_vector(31 downto 0);
signal n72 : std_logic := '0';
signal n73 : std_logic := '0';
signal n74 : std_logic := '0';
signal n75 : std_logic := '0';
signal n76 : std_logic_vector(0 downto 0) := (others=>'0');
signal n77 : std_logic_vector(0 downto 0) := (others=>'0');
signal n78 : std_logic := '0';
signal n79 : std_logic_vector(31 downto 0) := (others=>'0');
begin
n29 <= n14(31 downto 20);
n30 <= n14(31 downto 25) & n14(11 downto 7);
n31 <= n14(31) & n14(7) & n14(30 downto 25) & n14(11 downto 8);
n32 <= n14(31 downto 12);
n33 <= n14(31) & n14(19 downto 12) & n14(20) & n14(30 downto 21);
n36 <= signed(n34);
n37 <= signed(n35);
n38 <= unsigned(n34);
n39 <= unsigned(n35);
n43 <= signed(n29);
n44 <= resize(n43, 32);
n45 <= signed(n30);
n46 <= resize(n45, 32);
n47 <= signed(n32) & x"000";
n70 <= '1' when (n16 = '1') and (n66 = '1') and (n69(31 downto 28) = x"2") else '0';
n80 : process(n10) is
variable n81 : integer range 0 to 127 := 0;
variable n82 : std_logic := '1';
begin
if rising_edge(n10) then
if n81 = 127 then
n82 := '0';
else
n81 := n81 + 1;
n82 := '1';
end if;
n11 <= n82;
end if;
end process;
n34 <= n9(to_integer(unsigned(n19)));
n35 <= n9(to_integer(unsigned(n18)));
n83: process(n20, n37, n44, n17, n22, n34, n36, n38) is
variable n84 : signed(31 downto 0);
variable n85 : unsigned(31 downto 0);
variable n86 : std_logic_vector(32 downto 0);
variable n87 : signed(32 downto 0);
variable n88 : std_logic;
variable n89 : std_logic;
variable n90 : std_logic;
variable n91 : std_logic;
begin
if n22(5) = '0' then 
n84 := n44;
n85 := unsigned(n44);
n91 := '0';
else 
n84 := signed(n37);
n85 := unsigned(n37);
n91 := n17(5); 
end if;
if n36 < n84 then
n88 := '1';
else
n88 := '0';
end if;
if n38 < n85 then
n89 := '1';
else
n89 := '0';
end if;
if n38 = n85 then
n90 := '1';
else
n90 := '0';
end if;
n40 <= n88; 
n41 <= n89; 
n42 <= n90;
n71 <= (others=>'0');
case n20 is
when "000" => 
if n91 = '1' then
n71 <= std_logic_vector( n36 - n84 );
else
n71 <= std_logic_vector( n36 + n84 );
end if;
when "110" => 
n71 <= std_logic_vector(n36) or std_logic_vector(n84);
when "111" => 
n71 <= std_logic_vector(n36) and std_logic_vector(n84);
when "001" => 
case n85(4 downto 0) is
when "00010" => n71 <= std_logic_vector(shift_left(unsigned(n34), 2));
when "01000" => n71 <= std_logic_vector(shift_left(unsigned(n34), 8));
when others => n71 <= std_logic_vector(shift_left(unsigned(n34), 16));
end case;
when others =>
n71 <= (others=>'0');
end case;
end process;
n53 <= n16 when n22 = "0000011" else '0';
n57 <= unsigned(n36 + n44);
n54 <= n53 when n57(31 downto 28) = "0010" else '0';
n56 <= n55 when n58(31 downto 28) = "0010" else '0';
process(n10)
begin
if rising_edge(n10) then
n59 <= n7(to_integer(n57(n5-1+2 downto 0+2)));
end if;
end process;
process (n59, n58, n26 ) is
begin
case n26 is
when "100" => 
case n58(1 downto 0) is
when "00" => 
n60(7 downto 0) <= n59(7 downto 0);
n60(31 downto 8) <= (others=>'0');
when "01" => 
n60(7 downto 0) <= n59(15 downto 8);
n60(31 downto 8) <= (others=>'0');
when "10" => 
n60(7 downto 0) <= n59(23 downto 16);
n60(31 downto 8) <= (others=>'0');
when "11" => 
n60(7 downto 0) <= n59(31 downto 24);
n60(31 downto 8) <= (others=>'0');
when others => 
n60 <= n59;
end case;
when others =>
n60 <= n59;
end case;
end process;
process(n10)
begin
if rising_edge(n10) then
n61 <= n53 and n16;
end if;
end process;
with n58(31 downto 28) select n62 <= 
n60 when "0001", n64 when "0010", x"00000001" when others;
with n58(31 downto 28) select n63 <= 
n61 when "0001", n65 when "0010", '1' when others;
with n58(5 downto 2) select n64 <= 
x"00000001" when others;
with n58(5 downto 2) select n65 <= 
n78 when "0000",
'1' when others;
n69 <= unsigned(n36 + n46);
n66 <= n16 when n22 = "0100011" else '0';
process(n20,n69,n35) is
begin
n68 <= n35;
case n20 is
when "000" =>
case n69(1 downto 0) is
when "00" => 
n67 <= "0001";
n68( 7 downto 0) <= n35(7 downto 0);
when "01" => 
n67 <= "0010";
n68(15 downto 8) <= n35(7 downto 0);
when "10" => 
n67 <= "0100";
n68(23 downto 16) <= n35(7 downto 0);
when "11" => 
n67 <= "1000";
n68(31 downto 24) <= n35(7 downto 0);
when others => n67 <= "0001";
end case;
when "001" =>
if n69(1)='0' then
n67 <= "0011";
else
n67 <= "1100";
n68(31 downto 16) <= n35(15 downto 0);
end if;
when others =>
n67 <= "1111";
end case;
end process;
WRP : process(n10)
begin
if rising_edge(n10) then
if( n66 = '1' and n69(31 downto 28) = "0001" ) then
if n67(0) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(7 downto 0) := n68(7 downto 0);
end if;
if n67(1) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(15 downto 8) := n68(15 downto 8);
end if;
if n67(2) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(23 downto 16) := n68(23 downto 16);
end if;
if n67(3) = '1' then
n7(to_integer(n69(n5-1+2 downto 0+2)))(31 downto 24) := n68(31 downto 24);
end if;
end if;
end if;
end process;
n92 : process(n10) is
variable n93 : integer range 0 to n1 := 0;
begin
if rising_edge(n10) then 
n75 <= '0';
if n93 = n1 then
n75 <= '1';
n93 := 0;
end if;
n93 := n93 + 1;
end if;
end process;
n94 : process(n10) is
variable n95 : integer range 0 to 1000 := 0;
begin
if rising_edge(n10) then
n74 <= '0';
if n95 = 1000 then
n74 <= '1';
n95 := 0;
end if;
if n75 = '1' then
n95 := n95 + 1;
end if;
end if;
end process;
n96 : process(n10) is
variable n97 : unsigned(31 downto 0) := to_unsigned(0, 32);
variable n98 : unsigned(31 downto 0) := to_unsigned(0, 32);
variable n99 : std_logic := '0';
begin
if rising_edge(n10) then
n78 <= '0';
if n11 = '1' then
n97 := (others=>'0');
n98 := (others=>'0');
n79 <= (others=>'0');
elsif n70='1' and n69(5 downto 2) = "0000" then 
n97 := unsigned(n68);
n98 := unsigned(n68);
elsif n70='1' and n69(5 downto 2) = "0001" then 
n79 <= n68;
else
if n79(16) = '1' then
if n97 = x"00000000" then
n97 := n98;
n78 <= '1';
n76(0) <= n79(17);
else
case n79(25 downto 24) is
when "00" =>
n99 := '1';
when "01" =>
n99 := n75;
when "10" =>
n99 := n74;
when others =>
n99 := '0';
end case;
if n99 = '1' then
n97 := n97 - 1;
end if;
end if;
end if;
end if;
if n77(0) = '1' then
n76(0) <= '0';
end if;
end if;
end process;
n100 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio0 <= '0';
elsif n70='1' and n69(5 downto 2) = "0010" then 
Gpio0 <= n68(0);
end if;
end if;
end process;
n101 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio1 <= '0';
elsif n70='1' and n69(5 downto 2) = "0011" then 
Gpio1 <= n68(0);
end if;
end if;
end process;
n102 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio2 <= '0';
elsif n70='1' and n69(5 downto 2) = "0100" then 
Gpio2 <= n68(0);
end if;
end if;
end process;
n103 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio3 <= '0';
elsif n70='1' and n69(5 downto 2) = "0101" then 
Gpio3 <= n68(0);
end if;
end if;
end process;
n104 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio4 <= '0';
elsif n70='1' and n69(5 downto 2) = "0110" then 
Gpio4 <= n68(0);
end if;
end if;
end process;
n105 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio5 <= '0';
elsif n70='1' and n69(5 downto 2) = "0111" then 
Gpio5 <= n68(0);
end if;
end if;
end process;
n106 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio6 <= '0';
elsif n70='1' and n69(5 downto 2) = "1000" then 
Gpio6 <= n68(0);
end if;
end if;
end process;
n107 : process(n10) is
begin
if rising_edge(n10) then
if n11 = '1' then
Gpio7 <= '0';
elsif n70='1' and n69(5 downto 2) = "1001" then 
Gpio7 <= n68(0);
end if;
end if;
end process;
process( n10 ) is
variable n108 : std_logic := '0';
variable n109 : std_logic_vector(1 downto 0);
variable n110 : std_logic := '0'; 
variable n111 : std_logic_vector(31 downto 0); 
variable n112 : std_logic_vector(4 downto 0) := "00010";
variable n113 : unsigned(31 downto 0) := n0; 
variable n114 : std_logic := '0'; 
variable n115 : unsigned(31 downto 0); 
variable n116 : std_logic:= '0'; 
variable n117 : std_logic := '0';
variable n118 : std_logic := '0';
variable n119 : unsigned(31 downto 0) := n0; 
variable n120 : std_logic_vector(31 downto 0); 
begin
if rising_edge( n10 ) then
n108 := '0';
n116 := '1';
n114 := '0';
n110 := '0'; 
n111 := "0010" & x"0000000";
n55 <= '0';
if n118 = '1' then 
if n48 = '1' then
n110 := '1';
n111 := n49;
n118 := '0';
else
n109 := "00";
n108 := '1';
n116 := '0';
end if;
elsif n117 = '1' then
n55 <= '1';
if n63 = '1' then
n110 := '1';
n111 := n62;
n117 := '0';
else
n109 := "00";
n108 := '1';
n116 := '0';
end if;
elsif n16 = '1' then
n112 := n21;
n58 <= n57;
n15 <= n14;
case n22 is
when "0110111" => 
n110 := '1';
n111(31 downto 12) := n32;
when "0010111" => 
n110 := '1'; 
n111 := std_logic_vector( signed(n12) + n47 );
when "1101111" => 
n110 := '1'; 
n111 := std_logic_vector(n119); 
n115 := unsigned( signed(n12) + signed(n33&'0') );
n114 := '1';
when "1100111" => 
n110 := '1'; 
n111 := std_logic_vector(n119); 
n115 := unsigned(n43 + n36);
n114 := '1';
when "1100011" => 
n115 := unsigned( signed(n12) + signed(n31&'0') );
case n20 is 
when "000" => 
if n42 = '1' then
n114 := '1';
end if;
when "001" => 
if n42 = '0' then
n114 := '1';
end if;
when "100" => 
if n40 = '1' then
n114 := '1';
end if;
when "101" => 
if n40 = '0' then
n114 := '1';
end if;
when "110" => 
if n41 = '1' then
n114 := '1';
end if;
when "111" => 
if n41 = '0' then
n114 := '1';
end if;
when others=>
end case;
when "0000011" => 
n109 := "00";
n108 := '1';
n116 := '0';
n117 := '1';
when "0100011" => 
when "0010011" => 
n110 := '1';
n111 := n71;
when "0110011" => 
n110 := '1';
n111 := n71;
when others =>
end case;
end if; 
if n11 = '1' then
n109 := "00";
n108 := '1';
n113 := n0;
n119 := n0;
n110 := '1';
n114 := '0';
n116 := '0';
n117 := '0';
n118 := '0';
elsif n114 = '1' then 
n109 := "00";
n108 := '1';
n113(n2-1+2 downto 0+2) := n115(n2-1+2 downto 0+2); 
elsif n116 = '1' then
n113(n2-1+2 downto 0+2) := n113(n2-1+2 downto 0+2)+1;
n108 := '1';
end if;
n13 <= n12;
n109 := n109(0) & n108;
n16 <= n109(1);
if (n110 = '1') and (n112 /= "00000") then
n9(to_integer(unsigned(n112))) <= n111;
end if;
if n11 = '1' then
n112 := "00010";
end if;
n14 <= n120;
n12 <= n119;
n120 := n4(to_integer(n113(n2-1+2 downto 0+2)));
n119 :=n113;
end if;
end process;
end architecture;
